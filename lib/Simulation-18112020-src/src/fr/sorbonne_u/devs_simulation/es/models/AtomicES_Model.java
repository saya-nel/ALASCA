package fr.sorbonne_u.devs_simulation.es.models;

// Copyright Jacques Malenfant, Sorbonne Universite.
// Jacques.Malenfant@lip6.fr
//
// This software is a computer program whose purpose is to provide a
// new implementation of the DEVS simulation standard for Java.
//
// This software is governed by the CeCILL-C license under French law and
// abiding by the rules of distribution of free software.  You can use,
// modify and/ or redistribute the software under the terms of the
// CeCILL-C license as circulated by CEA, CNRS and INRIA at the following
// URL "http://www.cecill.info".
//
// As a counterpart to the access to the source code and  rights to copy,
// modify and redistribute granted by the license, users are provided only
// with a limited warranty  and the software's author,  the holder of the
// economic rights,  and the successive licensors  have only  limited
// liability. 
//
// In this respect, the user's attention is drawn to the risks associated
// with loading,  using,  modifying and/or developing or reproducing the
// software by the user in light of its specific status of free software,
// that may mean  that it is complicated to manipulate,  and  that  also
// therefore means  that it is reserved for developers  and  experienced
// professionals having in-depth computer knowledge. Users are therefore
// encouraged to load and test the software's suitability as regards their
// requirements in conditions enabling the security of their systems and/or 
// data to be ensured and,  more generally, to use and operate it in the 
// same conditions as regards security. 
//
// The fact that you are presently reading this means that you have had
// knowledge of the CeCILL-C license and that you accept its terms.

import java.util.Vector;
import java.util.concurrent.TimeUnit;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.PriorityQueue;
import java.util.Set;
import fr.sorbonne_u.devs_simulation.es.events.ES_EventI;
import fr.sorbonne_u.devs_simulation.es.events.EventComparator;
import fr.sorbonne_u.devs_simulation.models.AtomicModel;
import fr.sorbonne_u.devs_simulation.models.events.EventI;
import fr.sorbonne_u.devs_simulation.models.time.Duration;
import fr.sorbonne_u.devs_simulation.models.time.Time;
import fr.sorbonne_u.devs_simulation.simulators.interfaces.SimulatorI;

// -----------------------------------------------------------------------------
/**
 * The class <code>AtomicES_Model</code> implements the behaviours of atomic
 * model in event scheduling simulation models.
 *
 * <p><strong>Description</strong></p>
 * 
 * ES stands for Event Scheduling (ES) world view, a type of discrete event
 * simulation where the progress of the simulation revolves around
 * event processing, which causes modifications to the state and the
 * scheduling of new events.
 * 
 * When casting ES simulations into a DEVS simulation framework, an event list
 * is added to the state to record the events that are scheduled to be simulated
 * in the future (in simulation time). The time advance function hence simply
 * returns the time to go until the next event in the event list.  Internal
 * transitions removes the next event from the event list, computes the next
 * state given this event, produces the future events and schedule them into
 * the event list of the new state. External transitions execute events
 * received from other models on the atomic model.
 * 
 * Hence, most of the processing done in state implementation:
 * 
 * <ul>
 * <li>the event list contains the list of events to be processed ordered
 *   by the simulation time of their occurrence and their priority if their
 *   time of occurrence is the same;</li>
 * <li>the time advance function returns the delay until the next event
 *   occurrence in simulation time;</li>
 * <li>the output function retrieves from the event list the exported events
 *   to be processed and returns them so that they will be propagated to
 *   their destination models;</li>
 * <li>the internal transition function calls its
 *   <code>processNextEvents</code> method which first retrieves the set of
 *   events that must be executed at the current time from the
 *   event list then for each event in turn it calls the method
 *   <code>executeOn</code> on the event to perform the state modifications
 *   and then its <code>generateAndScheduleNewEvents</code> to add the new
 *   events generated by the current one to the event list of the model;</li>
 * <li>the external transition function is assumed to be called at the
 *   time of occurrence of the external event that is processed immediately
 *   by calling its <code>executeOn</code> method to perform the state
 *   modifications and then its <code>generateAndScheduleNewEvents</code>
 *   method to get the new events generated by the received one and
 *   schedule them into the event list.</li>
 * </ul>
 * 
 * <p>
 * The implementation provided here follows the spirit of the description
 * appearing in:
 * </p>
 * <ul>
 * <li>H. Vangheluwe, Discrete Event Modelling and Simulation,
 *   courseware, 2001.</li>
 * </ul>
 * 
 * <p><strong>Invariant</strong></p>
 * 
 * <pre>
 * invariant		true		// TODO
 * </pre>
 * 
 * <p>Created on : 2018-07-11</p>
 * 
 * @author	<a href="mailto:Jacques.Malenfant@lip6.fr">Jacques Malenfant</a>
 */
public abstract class	AtomicES_Model
extends		AtomicModel
{
	// -------------------------------------------------------------------------
	// Constants and variables
	// -------------------------------------------------------------------------

	private static final long 				serialVersionUID = 1L;
	protected static int					EVENT_QUEUE_INITIAL_CAPACITY = 11;
	protected final PriorityQueue<ES_EventI>	eventList;

	// -------------------------------------------------------------------------
	// Constructors
	// -------------------------------------------------------------------------

	/**
	 * create an atomic event scheduling model with the given URI (if null,
	 * one will be generated) and to be run by the given simulator (or by the
	 * one of an ancestor coupled model if null) using the given time unit for
	 * its clock.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code simulatedTimeUnit != null}
	 * pre	{@code simulationEngine == null || simulationEngine instanceof HIOA_AtomicEngine}
	 * post	{@code getURI() != null}
	 * post	{@code uri != null implies this.getURI().equals(uri)}
	 * post	{@code getSimulatedTimeUnit().equals(simulatedTimeUnit)}
	 * post	{@code simulationEngine != null implies getSimulationEngine().equals(simulationEngine)}
	 * post	{@code !isDebugModeOn()}
	 * </pre>
	 *
	 * @param uri					unique identifier of the model.
	 * @param simulatedTimeUnit		time unit used for the simulation clock.
	 * @param simulationEngine		simulation engine enacting the model.
	 * @throws Exception   			<i>TODO</i>.
	 */
	public				AtomicES_Model(
		String uri,
		TimeUnit simulatedTimeUnit,
		SimulatorI simulationEngine
		) throws Exception
	{
		super(uri, simulatedTimeUnit, simulationEngine);

		this.eventList = new PriorityQueue<ES_EventI>(
								AtomicES_Model.EVENT_QUEUE_INITIAL_CAPACITY,
								new EventComparator<ES_EventI>());
	}

	// -------------------------------------------------------------------------
	// Simulation protocol and related methods
	// -------------------------------------------------------------------------

	/**
	 * @see fr.sorbonne_u.devs_simulation.models.AtomicModel#initialiseState(fr.sorbonne_u.devs_simulation.models.time.Time)
	 */
	@Override
	public void			initialiseState(Time initialTime)
	{
		super.initialiseState(initialTime);
		this.eventList.clear();
	}

	/**
	 * @see fr.sorbonne_u.devs_simulation.models.interfaces.ModelI#timeAdvance()
	 */
	@Override
	public Duration		timeAdvance()
	{
		ES_EventI next = this.eventList.peek();
		Duration ret = null;
		if (next != null) {
			ret = next.getTimeOfOccurrence().
										subtract(this.getCurrentStateTime());
		} else {
			ret = Duration.INFINITY;
		}
		return ret;
	}

	/**
	 * for event scheduling models, extract all exported events that are in
	 * the event list with a time of occurrence equal to the time of the next
	 * event and return them as the current output.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	true		// no more preconditions.
	 * post	true		// no more postconditions.
	 * </pre>
	 * 
	 * @see fr.sorbonne_u.devs_simulation.models.interfaces.AtomicModelI#output()
	 */
	@Override
	public ArrayList<EventI>	output()
	{
		ArrayList<EventI> ret = null;
		if (!this.eventList.isEmpty()) {
			ret = new ArrayList<EventI>();
			try {
				Iterator<ES_EventI> iter = this.eventList.iterator();
				ES_EventI next = iter.next();
				Time t = next.getTimeOfOccurrence();
				assert	t.equals(this.getTimeOfNextEvent());
				while (next != null && next.getTimeOfOccurrence().equals(t)) {
					if (this.isExportedEventType(next.getClass())) {
						ret.add(next);
					}
					if (iter.hasNext()) {
						next = iter.next();
					} else {
						next = null;
					}
				};
				for (EventI e : ret) {
					this.eventList.remove(e);
				}
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
		}
		return ret;
	}

	/**
	 * @see fr.sorbonne_u.devs_simulation.models.AtomicModel#internalTransition()
	 */
	@Override
	public void			internalTransition()
	{
		if (this.hasDebugLevel(2)) {
			this.logMessage(
					"AtomicES_Model#internalTransition " + this.uri
					+ " time = " + this.getCurrentStateTime()
					+ " next event time = " + this.getTimeOfNextEvent());
		}

		assert	this.getNextTimeAdvance().equals(
					this.getTimeOfNextEvent().subtract(
											this.getCurrentStateTime()));

		Duration elapsedTime =
			this.getTimeOfNextEvent().subtract(this.getCurrentStateTime());
		this.currentStateTime = this.getTimeOfNextEvent();
		// Execute the non ES events.
		this.userDefinedInternalTransition(elapsedTime);
		// Extract the internal ES events which time of occurrence is equal
		// to the current state time.
		ES_EventI next = this.eventList.peek();
		Vector<ES_EventI> currentEvents = new Vector<ES_EventI>();
		while (next != null && next.getTimeOfOccurrence().
									equals(this.getCurrentStateTime())) {
			currentEvents.add(this.eventList.remove());
			next = this.eventList.peek();
		}
		// Execute the extracted events on the model, including the scheduling
		// of ES events generated by them.
		for (int i = 0 ; i < currentEvents.size() ; i++) {
			currentEvents.get(i).executeOn(this);
			this.scheduleEvents(currentEvents.get(i).
												generateNewEvents(this));
		}
		currentEvents.clear();
		this.nextTimeAdvance = this.timeAdvance();
		this.timeOfNextEvent =
						this.currentStateTime.add(this.nextTimeAdvance);	

		if (!this.getTimeOfNextEvent().equals(Time.INFINITY)) {
			assert	this.getTimeOfNextEvent().subtract(
												this.getCurrentStateTime()).
									equals(this.getNextTimeAdvance());
		}
	}

	/**
	 * for event scheduling models, first extract all imported events from
	 * the currently stored received events and add them to the event list
	 * so that they will be sorted by their order of execution, then the
	 * user defined external transition method is called to process the
	 * remaining events and finally the imported events are executed in
	 * their order on the model and their generated events added to the
	 * event list.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	true		// no more preconditions.
	 * post	true		// no more postconditions.
	 * </pre>
	 * 
	 * @see fr.sorbonne_u.devs_simulation.models.AtomicModel#externalTransition(fr.sorbonne_u.devs_simulation.models.time.Duration)
	 */
	@Override
	public void			externalTransition(Duration elapsedTime)
	{
		if (this.hasDebugLevel(2)) {
			this.logMessage("AtomicES_Model#externalTransition " + this.uri);
		}

		assert	this.getNextTimeAdvance().greaterThanOrEqual(elapsedTime);
		assert	this.getCurrentStateTime().add(elapsedTime).
								lessThanOrEqual(this.getTimeOfNextEvent());

		this.currentStateTime = this.currentStateTime.add(elapsedTime);

		// Extract imported event scheduling events from the currently
		// stored events.
		int count = 0;
		Set<EventI> extracted = new HashSet<EventI>();
		for (EventI e : this.currentStoredEvents) {
			if (e instanceof ES_EventI) {
				assert	e.getTimeOfOccurrence().
											equals(this.currentStateTime);
				// Inserting events in the event list allow to sort them
				// according to their priority.
				this.eventList.add((ES_EventI) e);
				extracted.add(e);
				count++;
			}
		}
		this.currentStoredEvents.removeAll(extracted);

		// Execute the remaining events
		if (this.currentStoredEvents.size() > 1) {
			this.confluentTransition(elapsedTime);
		} else {
			// there may be no standard event left, only scheduled ones.
			this.userDefinedExternalTransition(elapsedTime);
		}
		// all of them must have been processed.
		this.currentStoredEvents.clear();

		// Extracts the event scheduling events that are in the event list
		// and which time of occurrence is equal to the current state time.
		ES_EventI next = this.eventList.peek();
		Vector<ES_EventI> importedEvents = new Vector<ES_EventI>();
		Vector<ES_EventI> internalEvents = new Vector<ES_EventI>();
		while (next != null &&
				next.getTimeOfOccurrence().equals(this.currentStateTime)) {
			try {
				if (this.isImportedEventType(next.getClass())) {
					importedEvents.add(this.eventList.remove());
				} else {
					internalEvents.add(next);
				}
			} catch (Exception e1) {
				throw new RuntimeException(e1);
			}
			next = this.eventList.peek();
		}
		// The number of events must be exactly the same as the number that
		// were extracted from the incoming stored events.
		assert	count == importedEvents.size();
		// Put the internal ES events back in the event list so that they will
		// will be executed at the next internal transition.
		for (int i = internalEvents.size() - 1 ; i > 0 ; i--) {
			this.eventList.add(internalEvents.get(i));
		}
		internalEvents.clear();
		// Execute the ES imported events, including the scheduling of the
		// ES events that they generate.
		for (int i = 0 ; i < importedEvents.size() ; i++) {
			importedEvents.get(i).executeOn(this);
			this.scheduleEvents(importedEvents.get(i).
												generateNewEvents(this));
		}
		importedEvents.clear();

		this.nextTimeAdvance = this.timeAdvance();
		this.timeOfNextEvent =
						this.currentStateTime.add(this.nextTimeAdvance);

		// Postconditions
		if (!this.getTimeOfNextEvent().equals(Time.INFINITY)) {
			assert	this.getTimeOfNextEvent().subtract(
												this.getCurrentStateTime()).
									equals(this.getNextTimeAdvance());
		}
	}

	/**
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code for (EventI e : this.currentStoredEvents) { !(e instanceof ES_EventI) }}
	 * post	true		// no more postconditions.
	 * </pre>
	 * 
	 * @see fr.sorbonne_u.devs_simulation.models.AtomicModel#userDefinedExternalTransition(fr.sorbonne_u.devs_simulation.models.time.Duration)
	 */
	@Override
	public void			userDefinedExternalTransition(Duration elapsedTime)
	{
		super.userDefinedExternalTransition(elapsedTime);
		for (EventI e : this.currentStoredEvents) {
			assert	!(e instanceof ES_EventI);
		}
	}

	/**
	 * @see fr.sorbonne_u.devs_simulation.models.AtomicModel#confluentTransition(fr.sorbonne_u.devs_simulation.models.time.Duration)
	 */
	@Override
	public void			confluentTransition(Duration elapsedTime)
	{
		throw new RuntimeException("AtomicES#confluentTransition not"
												+ " implemented yet!");
	}

	/**
	 * @see fr.sorbonne_u.devs_simulation.models.AtomicModel#userDefinedConfluentTransition(fr.sorbonne_u.devs_simulation.models.time.Duration)
	 */
	@Override
	public void			userDefinedConfluentTransition(Duration elapsedTime)
	{
		// TODO Auto-generated method stub
		throw new RuntimeException(
					"AtomicES#userDefinedConfluentTransition not"
												+ " implemented yet!");
	}

	/**
	 * schedule new events resulting from the execution of a previous
	 * event that generated them.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code event != null}
	 * post	{@code getNumberOfScheduledEvents() == this.getNumberOfScheduledEvents()at_pre + 1}
	 * </pre>
	 *
	 * @param event		event to be scheduled.
	 */
	protected void		scheduleEvent(ES_EventI event)
	{
		assert	event != null;
		int numberOfScheduledEvents_at_pre = this.getNumberOfScheduledEvents();
		this.eventList.add(event);
		assert	this.getNumberOfScheduledEvents() ==
									numberOfScheduledEvents_at_pre + 1;
	}

	/**
	 * schedule new events resulting from the execution of a previous
	 * event that generated them.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	{@code events != null}
	 * post	{@code getNumberOfScheduledEvents() == getNumberOfScheduledEvents()at_pre + events.size()}
	 * </pre>
	 *
	 * @param events	set of events to be scheduled.
	 */
	protected void		scheduleEvents(Set<ES_EventI> events)
	{
		assert	events != null;
		int numberOfScheduledEvents_at_pre = this.getNumberOfScheduledEvents();
		this.eventList.addAll(events);
		assert	this.getNumberOfScheduledEvents() ==
							numberOfScheduledEvents_at_pre + events.size();
	}

	/**
	 * return the number of events currently scheduled.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	true		// no precondition.
	 * post	{@code ret >= 0}
	 * </pre>
	 *
	 * @return	the number of events currently scheduled.
	 */
	protected int		getNumberOfScheduledEvents()
	{
		return this.eventList.size();
	}

	// -------------------------------------------------------------------------
	// Debugging behaviour
	// -------------------------------------------------------------------------

	/**
	 * @see fr.sorbonne_u.devs_simulation.models.AtomicModel#showCurrentStateContent(java.lang.String, fr.sorbonne_u.devs_simulation.models.time.Duration)
	 */
	@Override
	public void			showCurrentStateContent(
		String indent,
		Duration elapsedTime
		)
	{
		super.showCurrentStateContent(indent, elapsedTime);
		System.out.println(indent + "event list = " +
												this.eventListAsString());
	}

	/**
	 * return a string representation of the event list of this model.
	 * 
	 * <p><strong>Contract</strong></p>
	 * 
	 * <pre>
	 * pre	true		// no precondition.
	 * post	true		// no postcondition.
	 * </pre>
	 *
	 * @return	a string representation of the event list of this model.
	 */
	protected String	eventListAsString()
	{
		String evl = "EventList{";
		int n = this.eventList.size();
		Iterator<ES_EventI> iter = this.eventList.iterator();
		while (iter.hasNext()) {
			evl += iter.next().eventAsString();
			n--;
			if (n >= 1) {
				evl += ", ";
			}
		}
		evl += "}";
		return evl;
	}

	/**
	 * @see fr.sorbonne_u.devs_simulation.models.AtomicModel#modelContentAsString(java.lang.String)
	 */
	@Override
	protected String	modelContentAsString(String indent)
	{
		String ret = super.modelContentAsString(indent);
		ret += indent + "event list = " + this.eventListAsString() + "\n";
		return ret;
	}
}
// -----------------------------------------------------------------------------
